\section{Ký và xác thực chữ ký số RSA theo cơ chế \texttt{pkeyutl} của OpenSSL}
\label{sec:rsa_signature_openssl}

Bài tập này tập trung vào việc tìm hiểu cơ chế chữ ký điện tử RSA mà OpenSSL cung cấp thông qua lệnh \texttt{pkeyutl}. Về mặt thao tác, OpenSSL cho phép (i) ký một thông điệp \texttt{<mess>} bằng khóa bí mật RSA trong \texttt{<priv.pem>} để sinh ra chữ ký \texttt{<sign>}, và (ii) xác thực chữ ký \texttt{<sign>} trên \texttt{<mess>} bằng khóa công khai RSA trong \texttt{<pub.pem>}.

Trên cơ sở đó, nhóm hiện thực một chương trình Python \texttt{rsa\_signature.py} nhằm tái hiện đúng hành vi của OpenSSL: chương trình ký và xác thực tương thích chéo với các lệnh sau:
\begin{verbatim}
openssl pkeyutl -in <mess> -out <sign> -inkey <priv.pem> -sign
openssl pkeyutl -in <mess> -sigfile <sign> -inkey <pub.pem> -pubin -verify
\end{verbatim}
Qua đó, bài làm vừa đóng vai trò “giải thích cơ chế” (mô tả thuật toán/padding), vừa đóng vai trò “hiện thực” (viết chương trình ký/xác thực và kiểm thử chéo với OpenSSL).

\subsection{Cơ sở lý thuyết: RSASSA và biến thể \texorpdfstring{``raw RSA''}{raw RSA} trong \texttt{pkeyutl}}
\label{ssec:rsa_sig_theory}

Theo chuẩn PKCS\#1 (RFC 8017), chữ ký RSA là sự kết hợp giữa (1) một \textit{encoding method} để biến thông điệp thành một khối có độ dài bằng mô-đun RSA và (2) phép toán nguyên thủy RSA trên khóa bí mật/công khai. Cụ thể, quy trình chuẩn \texttt{RSASSA-PKCS1-v1\_5} gồm hai primitive \texttt{RSASP1} (ký) và \texttt{RSAVP1} (xác minh), kèm theo encoding \texttt{EMSA-PKCS1-v1\_5} \cite{rfc8017}. RFC 8017 mô tả rất rõ các bước: chuyển đổi chuỗi byte sang số nguyên (\texttt{OS2IP}), áp dụng primitive RSA (lũy thừa mô-đun), rồi chuyển ngược lại về chuỗi byte độ dài $k$ (\texttt{I2OSP}); đồng thời có kiểm tra độ dài chữ ký và điều kiện hợp lệ \cite{rfc8017}.

Tuy nhiên, điểm đáng chú ý của OpenSSL \texttt{pkeyutl} là: mặc định \textbf{lệnh không tự hash dữ liệu đầu vào}. Thay vào đó, dữ liệu đưa vào thường được dùng trực tiếp làm input cho thuật toán ký/xác minh; nếu người dùng thiết lập \texttt{-pkeyopt digest:...} thì digest đó \emph{không dùng để hash input} mà chủ yếu dùng để “sanity-check” độ dài, và (trong một số thuật toán) để dựng các cấu trúc dạng \texttt{DigestInfo} của RSASSA-PKCS1-v1\_5 \cite{openssl_pkeyutl_freebsd}. Đặc biệt với RSA + PKCS\#1 v1.5 padding, manpage nêu rằng nếu \textbf{không đặt message digest}, dữ liệu được ký/xác minh trực tiếp, thay vì dựng \texttt{DigestInfo} \cite{openssl_pkeyutl_freebsd}. Điều này khớp với yêu cầu bài: “ký thô” nội dung tệp \texttt{<mess>}.

Từ góc nhìn encoding, chương trình trong bài này sử dụng chính hình thức \textbf{PKCS\#1 v1.5 Type 1 padding} (dành cho chữ ký):
\[
\text{EM} = 0x00 \,\|\, 0x01 \,\|\, \text{PS} \,\|\, 0x00 \,\|\, M,
\]
trong đó \texttt{PS} là chuỗi các byte \texttt{0xFF} để đệm đủ độ dài $k$ byte (và kéo theo ràng buộc độ dài tối đa của $M$ là $k-11$). Quy trình chuẩn RSASSA-PKCS1-v1\_5 trong RFC 8017 về bản chất cũng dựa trên cơ chế “encode $\rightarrow$ RSASP1/RSAVP1 $\rightarrow$ decode/so sánh” \cite{rfc8017}. Điểm khác biệt của bài này là \textbf{không hash} và không tạo \texttt{DigestInfo}; thay vào đó dùng $M$ trực tiếp như payload sau byte phân tách \texttt{0x00}.

%% (Hình minh họa gợi ý)
%% TODO: Vẽ sơ đồ cấu trúc EM của PKCS#1 v1.5 Type 1:
%% 0x00 | 0x01 | FF...FF | 0x00 | M
%% Và mô tả ràng buộc |M| <= k-11

\subsection{Thiết kế và hiện thực chương trình \texttt{rsa\_signature.py}}
\label{ssec:rsa_sig_impl}

Chương trình được hiện thực bằng Python và dùng thư viện \texttt{cryptography} để đọc khóa RSA từ các tệp PEM (private/public). Cụ thể, nhóm sử dụng cơ chế nạp khóa PEM từ tài liệu \texttt{Key Serialization} của \texttt{cryptography} để chuyển nội dung PEM thành đối tượng khóa RSA (phân biệt \texttt{RSAPrivateKey} và \texttt{RSAPublicKey}) \cite{cryptography_serialization_docs}. Sau khi có $(n,d)$ hoặc $(n,e)$, chương trình thực hiện phép lũy thừa mô-đun bằng \texttt{pow} trên số nguyên lớn của Python để tái hiện primitive RSA theo đúng định nghĩa trong RFC 8017 (ý tưởng \texttt{OS2IP} / \texttt{I2OSP} và \texttt{RSASP1} / \texttt{RSAVP1}) \cite{rfc8017}.

Về giao diện sử dụng, chương trình cung cấp hai lệnh con:
\begin{verbatim}
python rsa_signature.py sign <priv.pem> <message_file> <signature_output>
python rsa_signature.py verify <pub.pem> <message_file> <signature_file>
\end{verbatim}
mục tiêu là tương thích chéo với các lệnh \texttt{openssl pkeyutl} nêu trong mô tả bài. Mã nguồn bài làm được đóng gói trong tệp \texttt{rsa\_signature.py} \cite{rsa_signature_py}.

\subsection{Thuật toán ký: PKCS\#1 v1.5 Type 1 padding + \texorpdfstring{$m^d \bmod n$}{m^d mod n}}
\label{ssec:rsa_sig_sign_algo}

Ý tưởng ký trong bài này có thể tóm tắt thành hai lớp: (i) \textbf{encoding} thông điệp $M$ thành khối \texttt{EM} đúng kích thước khóa bằng padding PKCS\#1 v1.5 type 1; (ii) \textbf{ký RSA} bằng primitive \texttt{RSASP1} (tức lũy thừa $d$ modulo $n$) \cite{rfc8017}.

Chương trình trước hết tính kích thước khóa theo byte $k = \lceil \text{keyBits}/8 \rceil$, sau đó kiểm tra ràng buộc \texttt{|M| <= k-11}. Đây là ràng buộc thực tế do cấu trúc \texttt{0x00 0x01 PS 0x00 M} yêu cầu tối thiểu 11 byte overhead; nếu $M$ quá dài, encoding không thể tạo ra khối đúng chuẩn.

\begin{algorithm}[H]
\caption{Ký thông điệp RSA theo \texttt{pkeyutl} (raw data + PKCS\#1 v1.5 type 1)}
\label{alg:rsa_raw_sign}
\begin{algorithmic}[1]
\Function{SignRawRSA}{$privKey, M$}
    \State $(n,d) \gets$ \Call{ExtractPrivateNumbers}{$privKey$}
    \State $k \gets \lceil \text{keyBits}/8 \rceil$
    \If{$|M| > k-11$} \State \Return \textbf{error} \Comment{message too long} \EndIf
    \State $psLen \gets k - |M| - 3$
    \State $PS \gets \underbrace{0xFF \| 0xFF \| \cdots \| 0xFF}_{psLen\ \text{bytes}}$
    \State $\text{EM} \gets 0x00 \| 0x01 \| PS \| 0x00 \| M$
    \State $m \gets \Call{OS2IP}{\text{EM}}$ \Comment{bytes $\rightarrow$ integer}
    \State $s \gets m^d \bmod n$ \Comment{RSASP1 primitive}
    \State $S \gets \Call{I2OSP}{s, k}$ \Comment{integer $\rightarrow$ k-byte string}
    \State \Return $S$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Thuật toán xác thực: \texorpdfstring{$s^e \bmod n$}{s^e mod n} và kiểm tra padding}
\label{ssec:rsa_sig_verify_algo}

Đối với xác thực chữ ký, chương trình áp dụng primitive \texttt{RSAVP1}: chuyển chữ ký $S$ (bytes) thành số nguyên $s$, tính $m = s^e \bmod n$, rồi chuyển $m$ về chuỗi byte độ dài $k$ \cite{rfc8017}. Kết quả thu được là một \texttt{EM} “đã giải mã”. Thay vì tái-encode thông điệp như chuẩn RSASSA-PKCS1-v1\_5 (vốn sẽ hash + dựng \texttt{DigestInfo}), bài này triển khai theo hướng \textbf{message recovery} đúng với mục tiêu “raw data”: kiểm tra cấu trúc PKCS\#1 v1.5 type 1 và so sánh phần payload thu được với $M$.

Cụ thể, chương trình kiểm tra:
\begin{enumerate}
    \item Hai byte đầu phải là \texttt{0x00 0x01}.
    \item Tồn tại byte phân tách \texttt{0x00} sau chuỗi \texttt{0xFF...}.
    \item Tất cả byte padding giữa \texttt{0x01} và byte phân tách đều là \texttt{0xFF}.
    \item Phần còn lại sau byte phân tách phải trùng khớp với thông điệp gốc $M$.
\end{enumerate}
Các kiểm tra này đảm bảo chữ ký không chỉ “đúng RSA” mà còn đúng \textbf{định dạng} PKCS\#1 v1.5 type 1, tránh tình trạng chấp nhận các cấu trúc sai padding.

\begin{algorithm}[H]
\caption{Xác thực chữ ký RSA theo \texttt{pkeyutl} (raw data + PKCS\#1 v1.5 type 1)}
\label{alg:rsa_raw_verify}
\begin{algorithmic}[1]
\Function{VerifyRawRSA}{$pubKey, M, S$}
    \State $(n,e) \gets$ \Call{ExtractPublicNumbers}{$pubKey$}
    \State $k \gets \lceil \text{keyBits}/8 \rceil$
    \If{$|S| \neq k$} \State \Return \textbf{false} \EndIf \Comment{length check as in RFC}
    \State $s \gets \Call{OS2IP}{S}$
    \State $m \gets s^e \bmod n$ \Comment{RSAVP1 primitive}
    \State $\text{EM} \gets \Call{I2OSP}{m, k}$

    \If{$\text{EM}[0..1] \neq (0x00,0x01)$} \State \Return \textbf{false} \EndIf
    \State $idx \gets$ \Call{FindFirstByte}{$\text{EM}$, 0x00, start=2}
    \If{$idx = -1$} \State \Return \textbf{false} \EndIf
    \For{$i \gets 2$ \textbf{to} $idx-1$}
        \If{$\text{EM}[i] \neq 0xFF$} \State \Return \textbf{false} \EndIf
    \EndFor
    \State $M' \gets \text{EM}[idx+1 .. k-1]$
    \State \Return $(M' = M)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Đối chiếu với OpenSSL \texttt{pkeyutl} và kiểm thử tương thích}
\label{ssec:rsa_sig_compat}

Một yêu cầu cốt lõi của bài là đảm bảo chữ ký sinh ra bởi chương trình có thể xác thực bằng OpenSSL, và chữ ký sinh ra bởi OpenSSL có thể xác thực bằng chương trình. Về lý thuyết, tính tương thích này đến từ việc:
\begin{itemize}
    \item \texttt{pkeyutl} không hash input và có thể dùng dữ liệu đầu vào trực tiếp để ký/xác minh \cite{openssl_pkeyutl_freebsd}.
    \item Với RSA + PKCS\#1 padding, nếu không đặt digest, dữ liệu được ký trực tiếp thay vì dựng \texttt{DigestInfo} \cite{openssl_pkeyutl_freebsd}.
    \item Primitive RSA và kiểm tra độ dài chữ ký tuân theo mô tả trong RFC 8017 \cite{rfc8017}.
\end{itemize}

Vì vậy, nhóm sử dụng các cặp lệnh đối chiếu chéo sau trong kiểm thử:
\begin{enumerate}
    \item \textbf{Python $\rightarrow$ OpenSSL:} sinh chữ ký bằng \texttt{rsa\_signature.py sign}, sau đó \texttt{openssl pkeyutl -verify}.
    \item \textbf{OpenSSL $\rightarrow$ Python:} sinh chữ ký bằng \texttt{openssl pkeyutl -sign}, sau đó \texttt{rsa\_signature.py verify}.
\end{enumerate}
Kết quả kỳ vọng là cả hai chiều đều trả về “valid signature”, miễn là \texttt{<mess>} đủ ngắn (thỏa $|M|\le k-11$) và cặp khóa \texttt{<priv.pem>/<pub.pem>} tương ứng.

%% (Bảng gợi ý)
%% TODO: Bảng test-case (message length, key size, expected pass/fail)
%% | Key bits | k bytes | |M| | Expect |
%% |---------|---------|-----|--------|
%% | 1024    | 128     | 100 | Pass   |
%% | 1024    | 128     | 120 | Fail (too long) |

\subsection{Ghi chú về an toàn và phạm vi áp dụng}
\label{ssec:rsa_sig_security_note}

Cần nhấn mạnh rằng “ký thô” (raw RSA) như trong bài này chủ yếu phục vụ mục tiêu học thuật để nhìn rõ cơ chế padding và primitive RSA. Trong các hệ thống thực tế, chuẩn RSASSA-PKCS1-v1\_5 vẫn được dùng, nhưng RFC 8017 cũng lưu ý khuyến nghị chuyển dần sang PSS như một biện pháp phòng ngừa trước các phát triển tấn công trong tương lai \cite{rfc8017}. Ngoài ra, manpage của \texttt{pkeyutl} cũng nhấn mạnh rằng tuỳ padding/mode, độ dài dữ liệu đầu vào hợp lý thay đổi theo thuật toán; với RSA, dữ liệu ký không thể dài hơn mô-đun \cite{openssl_pkeyutl_freebsd}. Do đó, chương trình bài làm chủ động kiểm tra độ dài và báo lỗi rõ ràng để tránh tạo chữ ký không hợp lệ.

Chi tiết cách chạy chương trình và video demo xem tại phần phụ lục \ref{apd:tutorial}.
