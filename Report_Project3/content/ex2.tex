\section{Mã hóa và Giải mã RSA với OpenSSL}
\label{sec:rsa_encryption}

Tiếp nối bài tập trước về việc phân tích cấu trúc khóa RSA, bài tập này tập trung vào việc tìm hiểu và hiện thực cơ chế mã hóa/giải mã RSA mà OpenSSL sử dụng. Mục tiêu là xây dựng các chương trình có khả năng mã hóa và giải mã dữ liệu hoàn toàn tương thích với công cụ \texttt{openssl pkeyutl}.

\subsection{Cơ sở lý thuyết: Mã hóa RSA và PKCS\#1 v1.5 Padding}
\label{ssec:rsa_encryption_theory}

Hệ mật mã RSA (Rivest--Shamir--Adleman), được công bố lần đầu vào năm 1978, là một trong những hệ mật mã khóa công khai được sử dụng rộng rãi nhất \cite{rivest1978method}. Tính bảo mật của RSA dựa trên độ khó của bài toán phân tích thừa số nguyên tố (Integer Factorization Problem): cho một số nguyên lớn $n = p \times q$ với $p, q$ là các số nguyên tố, việc tìm lại $p$ và $q$ là một bài toán khó về mặt tính toán khi $n$ đủ lớn.

\subsubsection{Quy trình mã hóa và giải mã RSA cơ bản}
Với một cặp khóa RSA bao gồm khóa công khai $(n, e)$ và khóa bí mật $(n, d)$, quy trình mã hóa và giải mã được thực hiện như sau:
\begin{itemize}
    \item \textbf{Mã hóa:} Cho bản rõ $m$ (với $0 \leq m < n$), bản mã được tính bằng công thức:
    $$ c = m^e \pmod{n} $$
    
    \item \textbf{Giải mã:} Cho bản mã $c$, bản rõ được khôi phục bằng công thức:
    $$ m = c^d \pmod{n} $$
\end{itemize}

Tính đúng đắn của thuật toán được đảm bảo bởi định lý Euler--Fermat: vì $e \cdot d \equiv 1 \pmod{\lambda(n)}$, ta có:
$$ c^d = (m^e)^d = m^{ed} \equiv m \pmod{n} $$

\subsubsection{PKCS\#1 v1.5 Padding}
\label{sssec:pkcs1_padding}

Trong thực tế, việc mã hóa RSA ``thô'' (raw RSA) tiềm ẩn nhiều lỗ hổng bảo mật nghiêm trọng. Ví dụ, nếu bản rõ $m$ có giá trị nhỏ và số mũ công khai $e$ cũng nhỏ (như $e = 3$), thì $m^e$ có thể nhỏ hơn $n$, dẫn đến việc kẻ tấn công có thể tính trực tiếp $m = \sqrt[e]{c}$ mà không cần biết khóa bí mật \cite{boneh1999twenty}. Ngoài ra, RSA thô là tất định (deterministic), nghĩa là cùng một bản rõ sẽ luôn cho ra cùng một bản mã, điều này cho phép kẻ tấn công thực hiện các cuộc tấn công từ điển hoặc tấn công bản rõ đã biết.

Để khắc phục các vấn đề này, chuẩn PKCS\#1 (Public-Key Cryptography Standards \#1) định nghĩa các phương pháp đệm (padding) cho RSA. Phiên bản 1.5 của PKCS\#1 được mô tả chi tiết trong RFC 8017 \cite{rfc8017} và là phương pháp mặc định được OpenSSL sử dụng cho lệnh \texttt{pkeyutl} \cite{openssl_pkeyutl_freebsd}.

Cấu trúc của một khối tin nhắn sau khi được đệm theo PKCS\#1 v1.5 có dạng:
\begin{verbatim}
EM = 0x00 || 0x02 || PS || 0x00 || M
\end{verbatim}

Trong đó:
\begin{itemize}
    \item \texttt{0x00}: Byte khởi đầu, đảm bảo giá trị số của EM nhỏ hơn $n$.
    \item \texttt{0x02}: Byte định danh kiểu mã hóa (encryption).
    \item \texttt{PS}: Chuỗi đệm (Padding String), gồm các byte ngẫu nhiên khác 0, có độ dài tối thiểu 8 byte.
    \item \texttt{0x00}: Byte phân cách giữa padding và dữ liệu gốc.
    \item \texttt{M}: Bản rõ gốc (plaintext message).
\end{itemize}

%% Hinh ve minh hoa cau truc PKCS#1 v1.5 Padding
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        font=\small,
        block/.style={draw, rectangle, minimum height=1cm, align=center},
    ]
    % Các khối
    \node[block, minimum width=1cm, fill=gray!20] (b1) at (0,0) {\texttt{0x00}};
    \node[block, minimum width=1cm, fill=blue!20, right=0pt of b1] (b2) {\texttt{0x02}};
    \node[block, minimum width=4cm, fill=yellow!30, right=0pt of b2] (ps) {PS (random bytes $\geq$ 8)};
    \node[block, minimum width=1cm, fill=gray!20, right=0pt of ps] (sep) {\texttt{0x00}};
    \node[block, minimum width=3cm, fill=green!20, right=0pt of sep] (m) {M (plaintext)};
    
    % Mũi tên và nhãn tổng thể
    \draw[decorate, decoration={brace, amplitude=5pt, raise=3pt}] 
        (b1.north west) -- (m.north east) 
        node[midway, above=8pt] {EM = $k$ bytes (bằng kích thước khóa)};
    \end{tikzpicture}
    \caption{Cấu trúc khối tin nhắn PKCS\#1 v1.5 cho mã hóa RSA}
    \label{fig:pkcs1_structure}
\end{figure}

Do cấu trúc này, độ dài tối đa của bản rõ $M$ được giới hạn bởi công thức:
$$ |M|_{\max} = k - 11 \text{ bytes} $$
với $k$ là kích thước khóa RSA tính theo byte (ví dụ: khóa 2048-bit có $k = 256$ bytes, cho phép mã hóa tối đa 245 bytes dữ liệu).

\subsection{Quy trình mã hóa và giải mã của OpenSSL}
\label{ssec:openssl_encryption_process}

OpenSSL cung cấp lệnh \texttt{pkeyutl} để thực hiện các thao tác mã hóa và giải mã RSA. Quy trình này được mô tả chi tiết trong tài liệu hướng dẫn của OpenSSL \cite{openssl_pkeyutl_freebsd}.

\subsubsection{Quy trình mã hóa}
Khi thực hiện lệnh mã hóa:
\begin{verbatim}
openssl pkeyutl -in <plain> -out <cipher> -inkey <pub.pem> -pubin -encrypt
\end{verbatim}

OpenSSL thực hiện các bước sau:
\begin{enumerate}
    \item Đọc khóa công khai từ tệp \texttt{pub.pem} (đã được phân tích ở Bài 1).
    \item Đọc dữ liệu bản rõ từ tệp \texttt{plain}.
    \item Áp dụng PKCS\#1 v1.5 padding cho bản rõ, tạo thành khối EM.
    \item Chuyển đổi EM thành số nguyên $m$.
    \item Tính bản mã: $c = m^e \pmod{n}$.
    \item Chuyển đổi $c$ thành chuỗi byte có độ dài $k$ và ghi vào tệp \texttt{cipher}.
\end{enumerate}

\subsubsection{Quy trình giải mã}
Khi thực hiện lệnh giải mã:
\begin{verbatim}
openssl pkeyutl -in <cipher> -out <plain> -inkey <priv.pem> -decrypt
\end{verbatim}

OpenSSL thực hiện các bước sau:
\begin{enumerate}
    \item Đọc khóa bí mật từ tệp \texttt{priv.pem}.
    \item Đọc dữ liệu bản mã từ tệp \texttt{cipher}.
    \item Chuyển đổi bản mã thành số nguyên $c$.
    \item Tính: $m = c^d \pmod{n}$ (hoặc sử dụng CRT để tối ưu như đã mô tả ở Bài 1).
    \item Chuyển đổi $m$ thành chuỗi byte EM.
    \item Kiểm tra và loại bỏ PKCS\#1 v1.5 padding để thu được bản rõ gốc $M$.
    \item Ghi bản rõ vào tệp \texttt{plain}.
\end{enumerate}

%% Luu do quy trinh ma hoa va giai ma RSA
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        font=\small,
        node distance=0.8cm,
        process/.style={draw, rectangle, rounded corners, minimum width=3.5cm, minimum height=0.8cm, align=center},
        io/.style={draw, trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=2.5cm, minimum height=0.6cm, align=center},
        arrow/.style={-Stealth, thick},
    ]
    % Encryption flow
    \node[io, fill=green!20] (plain) {Bản rõ M};
    \node[process, fill=yellow!20, below=of plain] (pad) {PKCS\#1 v1.5 Padding};
    \node[process, fill=blue!20, below=of pad] (enc) {$c = m^e \pmod{n}$};
    \node[io, fill=red!20, below=of enc] (cipher) {Bản mã c};
    
    \draw[arrow] (plain) -- (pad);
    \draw[arrow] (pad) -- (enc) node[midway, right] {EM};
    \draw[arrow] (enc) -- (cipher);
    
    % Decryption flow
    \node[io, fill=red!20, right=4cm of plain] (cipher2) {Bản mã c};
    \node[process, fill=blue!20, below=of cipher2] (dec) {$m = c^d \pmod{n}$};
    \node[process, fill=yellow!20, below=of dec] (unpad) {Remove Padding};
    \node[io, fill=green!20, below=of unpad] (plain2) {Bản rõ M};
    
    \draw[arrow] (cipher2) -- (dec);
    \draw[arrow] (dec) -- (unpad) node[midway, right] {EM};
    \draw[arrow] (unpad) -- (plain2);
    
    % Labels
    \node[above=0.3cm of plain, font=\bfseries] {Mã hóa};
    \node[above=0.3cm of cipher2, font=\bfseries] {Giải mã};
    \end{tikzpicture}
    \caption{Lưu đồ quy trình mã hóa và giải mã RSA với PKCS\#1 v1.5 padding}
    \label{fig:rsa_enc_dec_flow}
\end{figure}

\subsection{Hiện thực chương trình mã hóa và giải mã}
\label{ssec:rsa_impl}

Để hiện thực các chương trình mã hóa và giải mã RSA tương thích với OpenSSL, ngôn ngữ Python được lựa chọn cùng với thư viện \texttt{cryptography} \cite{cryptography_serialization_docs}. Thư viện này cung cấp các hàm mã hóa cấp cao với hỗ trợ đầy đủ cho PKCS\#1 v1.5 padding, đảm bảo tính tương thích hoàn toàn với OpenSSL.

\subsubsection{Chương trình mã hóa}
Thuật toán \ref{alg:rsa_encrypt} mô tả quy trình mã hóa RSA được hiện thực trong chương trình \texttt{rsa\_encrypt.py} \cite{rsa_encrypt_py}.

\begin{algorithm}[H]
\caption{Mã hóa RSA với PKCS\#1 v1.5 Padding}
\label{alg:rsa_encrypt}
\begin{algorithmic}[1]
\Function{RSA\_Encrypt}{pubKeyFile, plainFile, cipherFile}
    \State publicKey $\gets$ \Call{LoadPublicKey}{pubKeyFile}
    \Comment{Đọc khóa công khai từ tệp PEM}
    \State plaintext $\gets$ \Call{ReadFile}{plainFile}
    \Comment{Đọc bản rõ}
    
    \State keySize $\gets$ publicKey.key\_size / 8
    \Comment{Kích thước khóa (bytes)}
    \State maxBlockSize $\gets$ keySize $-$ 11
    \Comment{Kích thước khối tối đa}
    
    \State cipherBlocks $\gets$ []
    \For{$i \gets 0$ \textbf{to} len(plaintext) \textbf{step} maxBlockSize}
        \State block $\gets$ plaintext[$i$ : $i +$ maxBlockSize]
        \State cipherBlock $\gets$ publicKey.\Call{encrypt}{block, PKCS1v15()}
        \State cipherBlocks.\Call{append}{cipherBlock}
    \EndFor
    
    \State \Call{WriteFile}{cipherFile, \Call{concat}{cipherBlocks}}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Chương trình giải mã}
Thuật toán \ref{alg:rsa_decrypt} mô tả quy trình giải mã RSA được hiện thực trong chương trình \texttt{rsa\_decrypt.py} \cite{rsa_decrypt_py}.

\begin{algorithm}[H]
\caption{Giải mã RSA với PKCS\#1 v1.5 Padding}
\label{alg:rsa_decrypt}
\begin{algorithmic}[1]
\Function{RSA\_Decrypt}{privKeyFile, cipherFile, plainFile}
    \State privateKey $\gets$ \Call{LoadPrivateKey}{privKeyFile}
    \Comment{Đọc khóa bí mật từ tệp PEM}
    \State ciphertext $\gets$ \Call{ReadFile}{cipherFile}
    \Comment{Đọc bản mã}
    
    \State blockSize $\gets$ privateKey.key\_size / 8
    \Comment{Kích thước mỗi khối bản mã}
    \State numBlocks $\gets$ len(ciphertext) / blockSize
    
    \State plaintextBlocks $\gets$ []
    \For{$i \gets 0$ \textbf{to} numBlocks $-$ 1}
        \State block $\gets$ ciphertext[$i \times$ blockSize : $(i+1) \times$ blockSize]
        \State plainBlock $\gets$ privateKey.\Call{decrypt}{block, PKCS1v15()}
        \State plaintextBlocks.\Call{append}{plainBlock}
    \EndFor
    
    \State \Call{WriteFile}{plainFile, \Call{concat}{plaintextBlocks}}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Kiểm tra tính tương thích với OpenSSL}
\label{ssec:rsa_compatibility}

Để đảm bảo chương trình hoạt động chính xác và tương thích hoàn toàn với OpenSSL, hai kịch bản kiểm tra đã được thực hiện:

\subsubsection{Kịch bản 1: Mã hóa bằng Python, giải mã bằng OpenSSL}
\begin{enumerate}
    \item Sử dụng \texttt{rsa\_encrypt.py} để mã hóa tệp bản rõ với khóa công khai.
    \item Sử dụng lệnh OpenSSL để giải mã:
    \begin{verbatim}
    openssl pkeyutl -in cipher_py -out plain_check -inkey priv.pem -decrypt
    \end{verbatim}
    \item So sánh \texttt{plain\_check} với tệp bản rõ gốc.
\end{enumerate}

\subsubsection{Kịch bản 2: Mã hóa bằng OpenSSL, giải mã bằng Python}
\begin{enumerate}
    \item Sử dụng lệnh OpenSSL để mã hóa:
    \begin{verbatim}
    openssl pkeyutl -in plain -out cipher_openssl -inkey pub.pem -pubin -encrypt
    \end{verbatim}
    \item Sử dụng \texttt{rsa\_decrypt.py} để giải mã tệp bản mã.
    \item So sánh kết quả giải mã với tệp bản rõ gốc.
\end{enumerate}

Cả hai kịch bản đều cho kết quả khớp hoàn toàn, chứng minh tính tương thích hai chiều giữa chương trình Python và OpenSSL.

%% Bảng tóm tắt các tệp trong Bài 2
\begin{table}[H]
\centering
\caption{Danh sách các tệp trong thư mục \texttt{Source/Bai\_2}}
\label{tab:bai2_files}
\begin{tabular}{|l|l|}
\hline
\textbf{Tệp} & \textbf{Mô tả} \\
\hline
\texttt{rsa\_encrypt.py} & Chương trình mã hóa RSA \\
\texttt{rsa\_decrypt.py} & Chương trình giải mã RSA \\
\texttt{priv.pem} & Khóa bí mật RSA 2048-bit \\
\texttt{pub.pem} & Khóa công khai RSA \\
\texttt{plain} & Tệp bản rõ mẫu \\
\texttt{cipher} & Tệp bản mã (được mã hóa bởi OpenSSL) \\
\texttt{README.md} & Hướng dẫn sử dụng \\
\hline
\end{tabular}
\end{table}

Chi tiết về cách chạy chương trình và video demo chương trình xem tại phần phụ lục \ref{apd:tutorial}.