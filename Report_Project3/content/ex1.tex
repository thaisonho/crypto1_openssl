\section{Phân tích và xác thực khóa RSA do OpenSSL tạo ra}
\label{sec:rsa_openssl}

Bài tập này tập trung vào việc nghiên cứu sâu hơn về cấu trúc bên trong của các khóa mã hóa được sinh ra bởi bộ công cụ OpenSSL, một trong những thư viện mật mã phổ biến và đáng tin cậy nhất hiện nay. Trong bài này, nhóm viết một chương trình Python có khả năng đọc, phân tích và bóc tách các thành phần toán học cấu thành nên một cặp khóa RSA (khóa công khai và khóa bí mật) được lưu trữ trong các tệp theo định dạng PEM (Privacy-Enhanced Mail). 

\subsection{Cơ sở lý thuyết: Cấu trúc khóa RSA theo chuẩn PKCS\#1}
\label{ssec:rsa_structure}

OpenSSL, khi tạo khóa RSA, tuân thủ chặt chẽ theo các quy định trong tài liệu RFC 8017, hay còn được biết đến với tên gọi PKCS\#1 (Public-Key Cryptography Standards \#1) \cite{rfc8017}. Các tệp khóa với phần mở rộng \texttt{.pem} về bản chất là các tệp văn bản chứa dữ liệu được mã hóa bằng Base64. Phần dữ liệu gốc trước khi mã hóa là một chuỗi byte được định dạng theo cú pháp ASN.1 (Abstract Syntax Notation One) với quy tắc mã hóa DER (Distinguished Encoding Rules).

Cấu trúc ASN.1 cho khóa công khai và khóa bí mật được OpenSSL định nghĩa rõ ràng trong mã nguồn của mình, cụ thể tại tệp \texttt{crypto/rsa/rsa\_asn1.c} \cite{openssl_rsa_asn1_c}, thông qua các macro định nghĩa chuỗi ASN.1.


\begin{figure}[H]
\centering
\begin{tikzpicture}[
    font=\small,
    box/.style={
        draw, 
        rectangle, 
        rounded corners, 
        align=center, 
        minimum width=8cm, 
        minimum height=0.9cm
    },
    layer/.style={
        draw, 
        rectangle, 
        rounded corners, 
        align=left, 
        minimum width=8cm
    },
    % Sử dụng mũi tên từ thư viện arrows.meta để đẹp hơn
    arrow/.style={-Stealth, thick} 
]
% PEM layer
\node[box] (pem) {
    \textbf{PEM file (.pem)}\\
    \texttt{-----BEGIN RSA PRIVATE KEY-----}\\
    \textit{Base64 encoded data}\\
    \texttt{-----END RSA PRIVATE KEY-----}
};

% DER layer
\node[box, below=0.8cm of pem] (der) {
    \textbf{DER encoding}\\
    Binary byte stream
};

% ASN.1 layer
\node[layer, below=0.8cm of der] (asn1) {
    \textbf{ASN.1 structure (PKCS\#1)}\\[2pt]
    \texttt{RSAPrivateKey ::= SEQUENCE \{}\\
    \hspace{0.5cm}\texttt{version}\\
    \hspace{0.5cm}\texttt{modulus (n)}\\
    \hspace{0.5cm}\texttt{publicExponent (e)}\\
    \hspace{0.5cm}\texttt{privateExponent (d)}\\
    \hspace{0.5cm}\texttt{prime1 (p)}\\
    \hspace{0.5cm}\texttt{prime2 (q)}\\
    \hspace{0.5cm}\texttt{exponent1, exponent2, coefficient}\\
    \texttt{\}}
};

% Arrows
\draw[arrow] (pem) -- node[right, midway, font=\footnotesize]{Base64 decode} (der);
\draw[arrow] (der) -- node[right, midway, font=\footnotesize]{DER parse} (asn1);
\end{tikzpicture}
\caption{Cấu trúc tệp PEM chứa khóa RSA theo chuẩn PKCS\#1 (RFC 8017)}
\label{fig:pem_rsa_structure}
\end{figure}

\subsubsection{Cấu trúc khóa công khai}
Khóa công khai, được lưu trong tệp \texttt{<pub.pem>}, có cấu trúc \texttt{RSAPublicKey} tương đối đơn giản. Nó là một chuỗi (SEQUENCE) bao gồm hai thành phần số nguyên theo định nghĩa trong \texttt{rsa\_asn1.c} \cite{openssl_rsa_asn1_c}:
\begin{itemize}
    \item \textbf{modulus (n):} Là mô-đun RSA, tích của hai số nguyên tố lớn $p$ và $q$.
    \item \textbf{publicExponent (e):} Là số mũ công khai, một số nguyên dương lẻ nhỏ, thường là 65537 ($2^{16} + 1$) để tối ưu hóa quá trình mã hóa và kiểm tra chữ ký.
\end{itemize}
Cấu trúc này chứa đủ thông tin cần thiết để thực hiện các thao tác mã hóa hoặc xác thực chữ ký số.

\subsubsection{Cấu trúc khóa bí mật}
Khóa bí mật, lưu trong tệp \texttt{<priv.pem>}, có cấu trúc phức tạp hơn nhiều, được mô tả rõ ràng tại hình \ref{fig:pem_rsa_structure}. Theo RFC 8017 và được định nghĩa trong mã nguồn OpenSSL \cite{openssl_rsa_asn1_c}, cấu trúc \texttt{RSAPrivateKey} là một chuỗi (SEQUENCE) chứa các thành phần sau:
\begin{itemize}
    \item \textbf{version:} Phiên bản của cấu trúc khóa. Giá trị là 0 cho khóa hai thừa số nguyên tố (p, q) và là 1 nếu là khóa đa thừa số (multi-prime), tương ứng với hằng số \texttt{RSA\_ASN1\_VERSION\_MULTI} trong OpenSSL \cite{openssl_rsa_ossl_c}.
    \item \textbf{modulus (n):} Mô-đun RSA, giống với thành phần trong khóa công khai.
    \item \textbf{publicExponent (e):} Số mũ công khai, giống với thành phần trong khóa công khai.
    \item \textbf{privateExponent (d):} Số mũ bí mật, được tính toán sao cho $d \cdot e \equiv 1 \pmod{\lambda(n)}$, với $\lambda(n)$ là hàm Carmichael.
    \item \textbf{prime1 (p):} Thừa số nguyên tố thứ nhất của $n$.
    \item \textbf{prime2 (q):} Thừa số nguyên tố thứ hai của $n$.
    \item \textbf{exponent1 (dmp1):} Là giá trị $d \pmod{p-1}$, được sử dụng cho tối ưu hóa CRT.
    \item \textbf{exponent2 (dmq1):} Là giá trị $d \pmod{q-1}$, được sử dụng cho tối ưu hóa CRT.
    \item \textbf{coefficient (iqmp):} Là nghịch đảo của $q$ theo mô-đun $p$, tức là $q^{-1} \pmod{p}$, là hệ số trong thuật toán Garner để tái tạo kết quả từ CRT.
\end{itemize}
Sự hiện diện của các thành phần $p, q, dmp1, dmq1, iqmp$ không chỉ đơn thuần là để lưu trữ. Chúng đóng vai trò cực kỳ quan trọng trong việc tối ưu hóa hiệu năng của các phép toán giải mã và ký số. Thay vì thực hiện phép tính lũy thừa mô-đun $m^d \pmod{n}$ trực tiếp trên các số rất lớn, OpenSSL sử dụng Định lý Đồng dư Trung Hoa (Chinese Remainder Theorem - CRT) để chia bài toán lớn thành hai bài toán nhỏ hơn trên các mô-đun $p$ và $q$, sau đó kết hợp kết quả. Quá trình này, được hiện thực trong hàm \texttt{rsa\_ossl\_mod\_exp} của OpenSSL \cite{openssl_rsa_ossl_c}, giúp tăng tốc độ xử lý lên đáng kể, thường là khoảng 4 lần.

Cụ thể, để tính $c^d \pmod n$, thay vì một phép lũy thừa lớn, OpenSSL thực hiện một chuỗi các phép toán nhỏ hơn:
\begin{enumerate}
    \item Tính hai giá trị trung gian: $c_p = c^d \pmod p$ và $c_q = c^d \pmod q$. Nhờ có các số mũ bí mật đã được tính toán trước, $dmp1 = d \pmod{p-1}$ và $dmq1 = d \pmod{q-1}$, hai phép toán này trở thành $c_p = c^{dmp1} \pmod p$ và $c_q = c^{dmq1} \pmod q$.
    \item Sử dụng hệ số CRT đã tính sẵn $iqmp = q^{-1} \pmod p$, kết quả cuối cùng được tái tạo lại bằng công thức: $c^d \equiv c_q + q \cdot [ (c_p - c_q) \cdot iqmp \pmod p ] \pmod n$.
\end{enumerate}
Quá trình này được tối ưu hóa cao độ trong mã nguồn OpenSSL, như trong hàm \texttt{rsa\_ossl\_mod\_exp} \cite{openssl_rsa_ossl_c}, nơi các phép toán được thực hiện một cách hiệu quả để giảm thiểu thời gian tính toán.

%% Bang bieu: Mo ta chi tiet cac thanh phan cua khoa bi mat RSA
%% | Ten thanh phan | Ky hieu toan hoc | Y nghia                                             |
%% |----------------|------------------|-----------------------------------------------------|
%% | version        | -                | Phiên bản (0 cho two-prime, 1 cho multi-prime)      |
%% | modulus        | n                | Tich cua cac so nguyen to p va q                     |
%% | publicExponent | e                | So mu cong khai                                     |
%% | privateExponent| d                | So mu bi mat                                        |
%% | prime1         | p                | Thua so nguyen to thu nhat                          |
%% | prime2         | q                | Thua so nguyen to thu hai                           |
%% | exponent1      | dmp1             | d mod (p-1), su dung cho toi uu hoa CRT             |
%% | exponent2      | dmq1             | d mod (q-1), su dung cho toi uu hoa CRT             |
%% | coefficient    | iqmp             | q^{-1} mod p, he so de ket hop ket qua CRT          |

\subsection{Hiện thực chương trình phân tích khóa}
\label{ssec:rsa_parser_impl}
Để hiện thực chương trình phân tích khóa theo yêu cầu, ngôn ngữ lập trình Python được lựa chọn cùng với thư viện \texttt{cryptography} \cite{rsa_key_parser_py}. Thư viện này cung cấp một giao diện cấp cao, mạnh mẽ để làm việc với các đối tượng và cấu trúc mật mã, giúp đơn giản hóa quá trình đọc và giải mã các tệp PEM.

Việc lựa chọn thư viện \texttt{cryptography} cho Python là có chủ đích, vì thư viện này đóng vai trò như một giao diện cấp cao, an toàn cho các hoạt động mật mã. Nó trừu tượng hóa các chi tiết phức tạp và dễ gây lỗi của việc phân tích cú pháp ASN.1/DER và xử lý các số nguyên lớn. Quan trọng hơn, \texttt{cryptography} thường liên kết với chính thư viện OpenSSL của hệ thống, do đó chương trình Python thực chất đang sử dụng cùng một nền tảng mật mã đã tạo ra các khóa đó để phân tích chúng. Điều này đảm bảo tính tương thích và chính xác cao nhất trong quá trình bóc tách các thành phần của khóa.

Quy trình cốt lõi của chương trình được mô tả trong Thuật toán \ref{alg:rsa_parser}. Chương trình bắt đầu bằng việc tải tệp khóa bí mật từ đường dẫn được cung cấp. Thư viện \texttt{cryptography} sẽ tự động xử lý việc giải mã Base64 và phân tích cấu trúc ASN.1. Từ đối tượng khóa đã được nạp, chương trình tiến hành trích xuất từng thành phần toán học thông qua các phương thức được định nghĩa sẵn, tương ứng với các trường trong cấu trúc \texttt{RSAPrivateKey} của OpenSSL \cite{rsa_key_parser_py}.

\begin{algorithm}[H]
\caption{Phân tích và trích xuất thành phần khóa bí mật RSA}
\label{alg:rsa_parser}
\begin{algorithmic}[1]
\Function{ParsePrivateKey}{filePath}
    \State pemData $\gets$ \Call{ReadFile}{filePath}
    \Comment{Đọc toàn bộ nội dung tệp PEM}
    \State privateKeyObject $\gets$ \Call{Serialization.LoadPemPrivateKey}{pemData}
    \Comment{Giải mã và phân tích cấu trúc ASN.1}
    
    \State privateNumbers $\gets$ privateKeyObject.\Call{private\_numbers}{}
    \State publicNumbers $\gets$ privateNumbers.\Call{public\_numbers}{}
    
    \State components $\gets$ \{\}
    \State components['n'] $\gets$ publicNumbers.n
    \State components['e'] $\gets$ publicNumbers.e
    \State components['d'] $\gets$ privateNumbers.d
    \State components['p'] $\gets$ privateNumbers.p
    \State components['q'] $\gets$ privateNumbers.q
    \State components['dmp1'] $\gets$ privateNumbers.dmp1
    \State components['dmq1'] $\gets$ privateNumbers.dmq1
    \State components['iqmp'] $\gets$ privateNumbers.iqmp
    
    \State \Return components
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Xác thực tính nhất quán của bộ khóa}
\label{ssec:rsa_validation}
Một bộ khóa RSA hợp lệ không chỉ đơn thuần là một tập hợp các số nguyên; chúng phải tuân thủ các mối quan hệ toán học chặt chẽ. Việc xác thực các mối quan hệ này là một bước vô cùng quan trọng để đảm bảo tính toàn vẹn và đúng đắn của bộ khóa. Tầm quan trọng của bước này được nhấn mạnh bởi sự tồn tại của hàm \texttt{RSA\_check\_key()} trong OpenSSL, vốn được dành riêng để kiểm tra tính nhất quán của khóa \cite{openssl_rsa_chk_c}. Một bộ khóa không nhất quán có thể là kết quả của lỗi trong quá trình sinh khóa, lỗi truyền dữ liệu, hoặc thậm chí là một nỗ lực tấn công có chủ đích. Việc sử dụng một khóa bị lỗi có thể dẫn đến kết quả giải mã/ký số sai, hoặc tệ hơn, làm lộ thông tin bí mật thông qua các cuộc tấn công kênh bên (side-channel attacks).

Chương trình được phát triển đã tích hợp một mô-đun xác thực, dựa trên các quy trình kiểm tra được định nghĩa trong mã nguồn của OpenSSL, cụ thể là tệp \texttt{crypto/rsa/rsa\_chk.c} \cite{openssl_rsa_chk_c} và được hiện thực trong tệp \texttt{rsa\_key\_parser.py} \cite{rsa_key_parser_py}. Các bước xác thực chính bao gồm:
\begin{enumerate}
    \item \textbf{Kiểm tra tích của các thừa số nguyên tố:} Mối quan hệ cơ bản nhất cần được kiểm tra là $n = p \times q$.
    
    \item \textbf{Kiểm tra quan hệ giữa số mũ công khai và bí mật:} Số mũ bí mật $d$ phải là nghịch đảo của số mũ công khai $e$ theo mô-đun $\lambda(n)$. Tức là $e \cdot d \equiv 1 \pmod{\lambda(n)}$. Ở đây, $\lambda(n)$ là hàm Carmichael, được định nghĩa là bội chung nhỏ nhất của $p-1$ và $q-1$, $\lambda(n) = \text{lcm}(p-1, q-1)$. Việc sử dụng $\lambda(n)$ thay vì hàm phi của Euler $\phi(n)=(p-1)(q-1)$ cho phép tồn tại các giá trị $d$ nhỏ hơn, nhưng vẫn đảm bảo tính đúng đắn của thuật toán. Đây là tiêu chuẩn được OpenSSL sử dụng trong quy trình xác thực khóa của mình \cite{openssl_rsa_chk_c}.
    
    \item \textbf{Kiểm tra các thành phần CRT:} Các hệ số dùng cho tối ưu hóa CRT cũng cần được xác thực lại:
    \begin{itemize}
        \item $dmp1$ phải bằng $d \pmod{p-1}$.
        \item $dmq1$ phải bằng $d \pmod{q-1}$.
        \item $iqmp$ phải bằng $q^{-1} \pmod{p}$.
    \end{itemize}
\end{enumerate}
Việc thực hiện thành công tất cả các kiểm tra này khẳng định rằng các thành phần được trích xuất từ tệp khóa là nhất quán về mặt toán học và tạo thành một bộ khóa RSA hợp lệ \cite{rsa_key_parser_py}. Thuật toán \ref{alg:rsa_validation} tóm tắt quy trình xác thực này.

\begin{algorithm}[H]
\caption{Xác thực tính nhất quán của các thành phần khóa RSA}
\label{alg:rsa_validation}
\begin{algorithmic}[1]
\Function{ValidateKeyComponents}{components}
    \State $n, e, d, p, q, dmp1, dmq1, iqmp \gets$ các giá trị từ \textit{components}
    \State valid $\gets$ \textbf{true}
    
    \If{$n \neq p \times q$}
        \State valid $\gets$ \textbf{false}
    \EndIf
    
    \State $\lambda_n \gets \text{lcm}(p-1, q-1)$
    \If{$(e \times d) \pmod{\lambda_n} \neq 1$}
        \State valid $\gets$ \textbf{false}
    \EndIf

    \If{$dmp1 \neq d \pmod{p-1}$}
        \State valid $\gets$ \textbf{false}
    \EndIf
    
    \If{$dmq1 \neq d \pmod{q-1}$}
        \State valid $\gets$ \textbf{false}
    \EndIf
    
    \State iqmp\_calc $\gets$ \Call{ModInverse}{q, p}
    \If{$iqmp \neq \text{iqmp\_calc}$}
        \State valid $\gets$ \textbf{false}
    \EndIf
    
    \State \Return valid
\EndFunction
\end{algorithmic}
\end{algorithm}

Chi tiết về cách chạy chương trình và video demo chương trình xem tại phần phụ lục \ref{apd:tutorial}